
===================================================================
Introduction
===================================================================

MPILEAKS is a library to detect application leaks of MPI objects. Using
the MPI profiling interface, it keeps track of all the MPI calls that
"allocate" and "free" objects.  At the end of the program, through
MPI_Finalize or before completion using MPI_Pcontrol, any unfreed
objects are identified and reported. 

MPILEAKS displays the stack trace where the leak occurred. The trace
includes file name and line number of the allocation call. Since many
MPI tasks may have the same leak, MPILEAKS displays a count
associated with each stack trace that computes the total number of
objects leaked across all processes for a given stack trace.
To get stack traces, MPILEAKS internally uses Todd Gamblin's Callpath
class.

https://github.com/tgamblin/callpath 

To acquire stack traces, applications must be compiled with the
'-g' option. However, it is not necessary to link to MPILEAKS to
use it.  One may select to use it at run time with existing executables
(see using MPILEAKS below). 

The following objects are tracked:
   x ==> supported
   - ==> still todo

   x Requests
     x pt2pt
     x persistent pt2pt
     x nonblocking file IO
     x generalized requests
   x Datatypes
   x Groups
   x Communicators
     x dup / split / create
     x intercomm create / merge
     x topology
     x dynamic processes
   x User-defined reduction ops
   x Files
   x Windows
   x Info objects
   x Attribute keyvals
   x Errhandlers (need example)
   x Memory
   - Ports
   - Published names


===================================================================
Building and using MPILEAKS
===================================================================

1. Edit the file:
   src/Makefile

2. Create libmpileaks.so in the path specified by 'defs.mk':
   cd src; make 

3. To build a simple MPI program with leaks:
   cd examples; make 
   Note that it is not necessary to link the program with the mpileaks
   library. Thus, rebuilding an MPI program to use this tool is not
   necessary, simply replace your 'srun' command with
   'scripts/srun-mpileaks' (see next step). 

4. To run the example:
   cd examples; make run

By default, mpileaks reports a single line from the stacktrace,
but one may increase the number of lines by setting the
$MPILEAKS_STACK_DEPTH environment variable, e.g., to get two lines:
  epxort MPILEAKS_STACK_DEPTH=2
To get the entire stacktrace, set this value to -1.


===================================================================
Extending MPILEAKS to handle other types
===================================================================
   
MPILEAKS is really a framework to detect mismatched function calls. As
such it can be extended to detect other types of leaks. Using this
framework is simple: (a) register the handle type used to uniquely
identify the function calls of interest; and (b) use the provided
functions 'allocate' and 'free' to associate a function call as
allocating or freeing resources. We provide an example below that,
for any given program, identifies MPI open files that are not closed.  

--
#include "mpi.h"
#include "mpileaks.h"                 /* Handle2Callpath */ 

/*
 * Instantiate class with the specific handle-type that identifies
 * one function call from another (MPI_File in this case). 
 * Define 'is_handle_null' for your specific handle type. 
 */
 
static class MPI_File2Callpath : public Handle2Callpath<MPI_File>
{
public: 
  bool is_handle_null(MPI_File handle) {
    return (handle == MPI_FILE_NULL) ? 1 : 0; 
  }
} File2Callpath; 


/* 
 * Associate function calls as "allocate" or "free" functions. 
 */ 

int MPI_File_open(MPI_Comm comm, char *filename, int amode, 
                  MPI_Info info, MPI_File *fh)
{
  int rc = PMPI_File_open(comm, filename, amode, info, fh); 
  File2Callpath.allocate(*fh); 
  return rc; 
}


int MPI_File_close(MPI_File *fh) 
{
  MPI_File handle_copy = *fh; 
  
  int rc = PMPI_File_close(fh);  
  File2Callpath.free(handle_copy); 
  
  return rc; 
}
